#저금통
list_a = [100, 500, 1000, 500, 100]
#저금통에 있는 동전의 종류 10, 50, 100, 500

#set
set_a = {1,2,3,1,2,3,1}
print(f'set_a = {set_a}')

#중복을 제거(허용하지 않는다)한다
print( set(list_a) )

set_2 = {1,2}
#print(set_a[0])
#set은 인덱스 보정이 안된다, 즉 순서를 바꿀 수 없다
#그래서 add나 remove를 사용할 수 없다

set_2.add(3)        # 집합에 3을 '추가'
print(set_2)        # {1, 2, 3}  (순서는 보장 안 됨)
set_2.remove(2)     # 집합에서 2 '삭제'
print(set_2)        # {1, 3}
print(set_2.pop())  # 임의의 원소 하나 '꺼내기'



"""🔹 `set`의 성격

* 중복 없는 집합 → 같은 값은 하나만 저장.
* 순서 없음 → `set[0]` 이런 식으로 인덱스로 접근할 수 없음.
* 하지만 원소를 넣거나 빼는(add/remove)건 가능해요.
  👉 순서를 다루는 게 아니라, "집합 안에 이 원소가 있냐 없냐"만 관리하기 때문이에요. """

""" 🔎 코드 해석

* `add(x)` → 집합에 x 추가 (이미 있으면 변화 없음).
* `remove(x)` → 집합에서 x 삭제 (없으면 에러).
* `pop()` → 집합에서 “임의의” 원소 하나를 꺼내고 제거. (어떤 게 나올지는 보장 ❌).

📌 핵심

* `set`은 \*\*인덱스(순번)\*\*로 요소를 다룰 수 없을 뿐,
  **원소 자체를 넣고 빼는(add/remove)** 건 당연히 됩니다.
* 즉, 리스트처럼 `0번째 자리에 삽입/삭제`는 안 되지만,
  **집합에 이 원소를 넣는다/뺀다**는 건 가능해요.


👉 정리하면:
* “순서가 없다 = 위치로 접근 불가”
* “add/remove 가능 = 값 자체로 추가/삭제는 가능”"""

